<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STICK FIGHTER - Fixed Version</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .left-panel {
            width: 250px;
            background: #2a2a2a;
            padding: 20px;
            border-right: 2px solid #333;
        }

        .game-area {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #f0f0f0;
            position: relative;
        }

        .canvas-container {
            position: relative;
            background: white;
            border: 3px solid #000;
            border-radius: 10px;
        }

        #gameCanvas {
            display: block;
            background: white;
        }

        .minimap {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 100px;
            height: 100px;
            background: #333;
            border: 2px solid #000;
            border-radius: 5px;
        }

        .controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 5px;
        }

        .wallet-section {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            color: white;
            min-width: 200px;
            z-index: 1000;
        }

        .wallet-button {
            background: linear-gradient(45deg, #9945FF, #14F195);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            margin: 5px 0;
            width: 100%;
            transition: all 0.3s;
        }

        .wallet-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(153, 69, 255, 0.4);
        }

        .wallet-button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        .wallet-info {
            font-size: 12px;
            margin-top: 10px;
            padding: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
            word-break: break-all;
        }

        .ca-section {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            color: white;
            min-width: 250px;
            z-index: 1000;
        }

        .ca-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #ff6b35;
        }

        .ca-address {
            font-size: 10px;
            background: rgba(255,255,255,0.1);
            padding: 8px;
            border-radius: 5px;
            margin-bottom: 10px;
            word-break: break-all;
            font-family: monospace;
        }

        .ca-links {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .ca-link {
            background: linear-gradient(45deg, #1da1f2, #00d4aa);
            color: white;
            text-decoration: none;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s;
        }

        .ca-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(29, 161, 242, 0.4);
        }

        .buy-button {
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
            transition: all 0.3s;
        }

        .buy-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 107, 53, 0.4);
        }

        .control-btn {
            background: #4a90e2;
            color: white;
            border: none;
            padding: 8px 12px;
            margin: 2px;
            border-radius: 3px;
            cursor: pointer;
        }

        .right-panel {
            width: 250px;
            background: #2a2a2a;
            padding: 20px;
            border-left: 2px solid #333;
        }

        .rename-section {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        .rename-input {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 1px solid #555;
            background: #444;
            color: white;
            border-radius: 3px;
        }

        .rename-btn {
            width: 100%;
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px;
            border-radius: 3px;
            cursor: pointer;
        }

        .leaderboard {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 5px;
        }

        .player-item {
            display: flex;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .player-rank {
            width: 20px;
            height: 20px;
            background: #ffd700;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: #000;
            margin-right: 10px;
        }

        .player-name {
            flex: 1;
            font-size: 14px;
        }

        .player-points {
            font-size: 14px;
            font-weight: bold;
            color: #4CAF50;
        }

        .music-controls {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        .music-controls h3 {
            margin: 0 0 10px 0;
            color: #4CAF50;
        }

        .music-controls button {
            width: 100%;
            margin-bottom: 10px;
        }

        .music-controls input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }

        .music-controls span {
            display: block;
            text-align: center;
            font-size: 12px;
            color: #ccc;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Left Panel -->
        <div class="left-panel">
            <h2>STICK FIGHTER</h2>
            <p><strong>Controls:</strong></p>
            <p>WASD - Move</p>
            <p>J - Punch</p>
            <p>K - Kick</p>
            <p><strong>Goal:</strong></p>
            <p>Kill enemies to grow bigger!</p>
        </div>

        <!-- Game Area -->
        <!-- Wallet Section - Outside Canvas -->
        <div class="wallet-section">
            <h3>üîó Solana Wallet</h3>
            <button id="connectWallet" class="wallet-button">Connect Wallet</button>
            <button id="disconnectWallet" class="wallet-button" style="display: none;">Disconnect</button>
            <div id="walletInfo" class="wallet-info" style="display: none;">
                <div><strong>Address:</strong> <span id="walletAddress"></span></div>
                <div><strong>Balance:</strong> <span id="walletBalance">0 SOL</span></div>
            </div>
        </div>

        <!-- CA Section - Contract Address & Links -->
        <div class="ca-section">
            <div class="ca-title">üí∞ $STICK Token</div>
            <div class="ca-address">
                <strong>CA:</strong> 7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU
            </div>
            <div class="ca-links">
                <a href="https://twitter.com/stickfighter" target="_blank" class="ca-link">üê¶ Twitter</a>
                <a href="https://discord.gg/stickfighter" target="_blank" class="ca-link">üí¨ Discord</a>
            </div>
            <button class="buy-button" onclick="buyStickToken()">üõí Buy $STICK</button>
        </div>

        <div class="game-area">
            <div class="canvas-container">
                <canvas id="gameCanvas" width="800" height="600"></canvas>
                
                <!-- Minimap -->
                <div class="minimap">
                    <canvas id="minimapCanvas" width="100" height="100"></canvas>
                </div>
                
                <!-- Controls -->
                <div class="controls">
                    <button class="control-btn" onclick="showControls()">‚öôÔ∏è Controls</button>
                    <button class="control-btn" onclick="toggleFullscreen()">üì∫ Fullscreen</button>
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="right-panel">
            <!-- Music Controls -->
            <div class="music-controls">
                <h3>üéµ Music</h3>
                <!-- Audio Background Music -->
                <audio id="bg-music" autoplay loop muted>
                    <source src="audio/stick-theme.mp3" type="audio/mpeg">
                </audio>
                <button class="control-btn" id="toggle-music-btn">üîä Play Music</button>
                <input type="range" id="volume-slider" min="0" max="100" value="20" />
                <span id="volumeText">20%</span>
            </div>
            
            <!-- Rename Section -->
            <div class="rename-section">
                <h3>Rename Player</h3>
                <input type="text" id="renameInput" class="rename-input" placeholder="Enter new name" maxlength="20">
                <button class="rename-btn" onclick="renamePlayer()">Rename</button>
            </div>
            
            <!-- Leaderboard -->
            <div class="leaderboard">
                <h3>üèÜ Top Players</h3>
                <div id="playersList">
                    <!-- Players will be added here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Solana Web3.js -->
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>

    <script>
        // Solana Wallet Integration
        let wallet = null;
        let connection = null;
        let publicKey = null;

        // Initialize Solana connection
        function initSolana() {
            try {
                connection = new solanaWeb3.Connection('https://api.mainnet-beta.solana.com');
                console.log('Solana connection initialized');
                
                // Check wallet availability
                checkWalletAvailability();
            } catch (error) {
                console.error('Failed to initialize Solana:', error);
            }
        }

        // Check wallet availability
        function checkWalletAvailability() {
            const connectBtn = document.getElementById('connectWallet');
            
            if (typeof window.solana !== 'undefined' && window.solana.isPhantom) {
                connectBtn.textContent = 'Connect Phantom Wallet';
                connectBtn.disabled = false;
                connectBtn.onclick = connectWallet;
                console.log('Phantom wallet detected');
            } else if (typeof window.solflare !== 'undefined') {
                connectBtn.textContent = 'Connect Solflare Wallet';
                connectBtn.disabled = false;
                connectBtn.onclick = connectWallet;
                console.log('Solflare wallet detected');
            } else {
                connectBtn.textContent = 'Connect Phantom Wallet';
                connectBtn.disabled = false;
                connectBtn.onclick = function() {
                    alert('Please install Phantom wallet from https://phantom.app/');
                    window.open('https://phantom.app/', '_blank');
                };
                console.log('No wallet detected');
            }
        }

        // Connect wallet
        async function connectWallet() {
            try {
                // Check if Phantom wallet is installed
                if (typeof window.solana !== 'undefined' && window.solana.isPhantom) {
                    // Phantom wallet
                    const response = await window.solana.connect();
                    publicKey = response.publicKey;
                    wallet = window.solana;
                    updateWalletUI();
                    console.log('Connected to Phantom wallet:', publicKey.toString());
                } else if (typeof window.solflare !== 'undefined') {
                    // Solflare wallet
                    const response = await window.solflare.connect();
                    publicKey = response.publicKey;
                    wallet = window.solflare;
                    updateWalletUI();
                    console.log('Connected to Solflare wallet:', publicKey.toString());
                } else {
                    alert('No Solana wallet found! Please install Phantom wallet from https://phantom.app/');
                }
            } catch (error) {
                console.error('Failed to connect wallet:', error);
                alert('Failed to connect wallet: ' + error.message);
            }
        }

        // Disconnect wallet
        async function disconnectWallet() {
            try {
                if (wallet && wallet.disconnect) {
                    await wallet.disconnect();
                }
                wallet = null;
                publicKey = null;
                updateWalletUI();
                console.log('Wallet disconnected');
            } catch (error) {
                console.error('Failed to disconnect wallet:', error);
            }
        }

        // Update wallet UI
        async function updateWalletUI() {
            const connectBtn = document.getElementById('connectWallet');
            const disconnectBtn = document.getElementById('disconnectWallet');
            const walletInfo = document.getElementById('walletInfo');
            const walletAddress = document.getElementById('walletAddress');
            const walletBalance = document.getElementById('walletBalance');

            if (publicKey) {
                connectBtn.style.display = 'none';
                disconnectBtn.style.display = 'block';
                walletInfo.style.display = 'block';
                
                // Show truncated address
                const address = publicKey.toString();
                walletAddress.textContent = address.slice(0, 8) + '...' + address.slice(-8);
                
                // Get balance
                try {
                    const balance = await connection.getBalance(publicKey);
                    const solBalance = balance / solanaWeb3.LAMPORTS_PER_SOL;
                    walletBalance.textContent = solBalance.toFixed(4) + ' SOL';
                } catch (error) {
                    walletBalance.textContent = 'Error loading balance';
                }
            } else {
                connectBtn.style.display = 'block';
                disconnectBtn.style.display = 'none';
                walletInfo.style.display = 'none';
            }
        }

        // Game variables
        let canvas, ctx, minimapCanvas, minimapCtx;
        let players = new Map();
        let currentPlayerId = 'player_' + Math.random().toString(36).substr(2, 9);
        let keys = {};
        let gameRunning = true;
        let attackEffects = [];
        
        // Camera system
        let cameraX = 0;
        let cameraY = 0;

        // Game settings
        const mapWidth = 1600;  // M·ªü r·ªông map
        const mapHeight = 1200; // M·ªü r·ªông map
        const canvasWidth = 800;
        const canvasHeight = 600;
        const playerSpeed = 3;
        const minPlayerSize = 20;
        const maxPlayerSize = 80;
        const attackRange = 50;
        const punchCooldown = 500;
        const kickCooldown = 800;
        
        // Sprite sheet settings
        const frameWidth = 64;
        const frameHeight = 64;
        const totalFrames = 5; // Idle, Stance, Punch, Kick, Run

        // Initialize game
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            minimapCanvas = document.getElementById('minimapCanvas');
            minimapCtx = minimapCanvas.getContext('2d');
            
            // Initialize Solana
            initSolana();
            
            // Setup wallet event listeners
            document.getElementById('connectWallet').addEventListener('click', connectWallet);
            document.getElementById('disconnectWallet').addEventListener('click', disconnectWallet);
            
            // Create current player
            addPlayer(currentPlayerId, 'Player#' + Math.random().toString(36).substr(2, 6));
            
            // Create 3 fixed bots
            addPlayer('bot_1', 'Bot#1');
            addPlayer('bot_2', 'Bot#2');
            addPlayer('bot_3', 'Bot#3');
            
            setupEventListeners();
            gameLoop();
            updateLeaderboard();
        }

        function addPlayer(id, name) {
            const player = {
                id: id,
                name: name,
                x: Math.random() * (mapWidth - 40) + 20,
                y: Math.random() * (mapHeight - 40) + 20,
                size: minPlayerSize,
                health: 100,
                maxHealth: 100,
                kills: 0,
                deaths: 0,
                points: 0,
                color: getRandomColor(),
                isBot: id.startsWith('bot_'),
                targetX: 0,
                targetY: 0,
                lastMoveTime: 0,
                // Sprite properties
                sprite: new Image(),
                frame: 0,
                animationTimer: 0,
                lastPunch: 0,
                lastKick: 0,
                facing: 1,
                isAttacking: false,
                attackType: null,
                attackTimer: 0,
                aiState: 'wander',
                targetPlayer: null,
                lastAttackTime: 0
            };
            
            players.set(id, player);
            return player;
        }

        function getRandomColor() {
            const colors = ['#ff6b35', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3', '#54a0ff'];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        function setupEventListeners() {
            document.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                
                if (e.code === 'KeyJ') {
                    handlePunch();
                }
                if (e.code === 'KeyK') {
                    handleKick();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });
        }

        function handlePunch() {
            const player = players.get(currentPlayerId);
            if (!player) return;
            
            const now = Date.now();
            if (now - player.lastPunch < punchCooldown) return;
            
            player.lastPunch = now;
            player.isAttacking = true;
            player.attackType = 'punch';
            player.attackTimer = 300;
            
            createAttackEffect(player.x, player.y, 'punch');
            checkAttack(player, 'punch');
        }

        function handleKick() {
            const player = players.get(currentPlayerId);
            if (!player) return;
            
            const now = Date.now();
            if (now - player.lastKick < kickCooldown) return;
            
            player.lastKick = now;
            player.isAttacking = true;
            player.attackType = 'kick';
            player.attackTimer = 400;
            
            createAttackEffect(player.x, player.y, 'kick');
            checkAttack(player, 'kick');
        }

        function createAttackEffect(x, y, type) {
            const effect = {
                x: x,
                y: y,
                type: type,
                timer: type === 'punch' ? 300 : 400,
                maxTimer: type === 'punch' ? 300 : 400
            };
            attackEffects.push(effect);
        }

        function checkAttack(attacker, attackType) {
            const damage = attackType === 'punch' ? 25 : 35;
            const range = attackType === 'punch' ? attackRange : attackRange + 10;
            
            for (let [id, target] of players) {
                if (id === attacker.id) continue;
                
                const dx = target.x - attacker.x;
                const dy = target.y - attacker.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < range) {
                    hitPlayer(attacker, target, damage);
                }
            }
        }

        function hitPlayer(attacker, target, damage) {
            target.health -= damage;
            
            if (target.health <= 0) {
                killPlayer(attacker, target);
            }
        }

        function updateCamera(player) {
            // Camera follows player
            cameraX = player.x - canvasWidth / 2;
            cameraY = player.y - canvasHeight / 2;
            
            // Keep camera within map bounds
            cameraX = Math.max(0, Math.min(mapWidth - canvasWidth, cameraX));
            cameraY = Math.max(0, Math.min(mapHeight - canvasHeight, cameraY));
        }

        function updatePlayer(player) {
            if (player.id === currentPlayerId) {
                updateHumanPlayer(player);
            } else if (player.isBot) {
                updateBotPlayer(player);
            }
            
            // Update attack timer
            if (player.isAttacking) {
                player.attackTimer -= 16;
                if (player.attackTimer <= 0) {
                    player.isAttacking = false;
                    player.attackType = null;
                }
            }
        }

        function updateHumanPlayer(player) {
            // Update camera to follow player
            updateCamera(player);
            
            let dx = 0, dy = 0;
            
            if (keys['KeyW'] || keys['ArrowUp']) dy -= playerSpeed;
            if (keys['KeyS'] || keys['ArrowDown']) dy += playerSpeed;
            if (keys['KeyA'] || keys['ArrowLeft']) {
                dx -= playerSpeed;
                player.facing = -1;
            }
            if (keys['KeyD'] || keys['ArrowRight']) {
                dx += playerSpeed;
                player.facing = 1;
            }
            
            if (dx !== 0 && dy !== 0) {
                dx *= 0.707;
                dy *= 0.707;
            }
            
            player.x += dx;
            player.y += dy;
            
            player.x = Math.max(player.size/2, Math.min(mapWidth - player.size/2, player.x));
            player.y = Math.max(player.size/2, Math.min(mapHeight - player.size/2, player.y));
        }

        function updateBotPlayer(player) {
            const now = Date.now();
            
            // Find nearest enemy
            let nearestEnemy = null;
            let nearestDistance = Infinity;
            
            for (let [id, otherPlayer] of players) {
                if (id === player.id) continue;
                
                const dx = otherPlayer.x - player.x;
                const dy = otherPlayer.y - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < nearestDistance) {
                    nearestDistance = distance;
                    nearestEnemy = otherPlayer;
                }
            }
            
            // AI State Machine
            if (nearestEnemy) {
                const dx = nearestEnemy.x - player.x;
                const dy = nearestEnemy.y - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 60) {
                    // Close enough to attack
                    player.aiState = 'attack';
                    player.targetPlayer = nearestEnemy;
                    
                    // Face the target
                    player.facing = dx > 0 ? 1 : -1;
                    
                    // Attack if cooldown is ready
                    if (now - player.lastAttackTime > 1000) {
                        const attackType = Math.random() < 0.6 ? 'punch' : 'kick';
                        botAttack(player, attackType);
                        player.lastAttackTime = now;
                    }
                } else {
                    // Chase the enemy
                    player.aiState = 'chase';
                    player.targetPlayer = nearestEnemy;
                    
                    const moveX = (dx / distance) * playerSpeed * 0.8;
                    const moveY = (dy / distance) * playerSpeed * 0.8;
                    
                    player.x += moveX;
                    player.y += moveY;
                    player.facing = dx > 0 ? 1 : -1;
                }
            } else {
                // No enemies nearby, wander
                player.aiState = 'wander';
                
                if (now - player.lastMoveTime > 2000) {
                    player.targetX = Math.random() * (mapWidth - 40) + 20;
                    player.targetY = Math.random() * (mapHeight - 40) + 20;
                    player.lastMoveTime = now;
                }
                
                const dx = player.targetX - player.x;
                const dy = player.targetY - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 5) {
                    const moveX = (dx / distance) * playerSpeed * 0.5;
                    const moveY = (dy / distance) * playerSpeed * 0.5;
                    
                    player.x += moveX;
                    player.y += moveY;
                    player.facing = dx > 0 ? 1 : -1;
                }
            }
            
            // Keep bot within bounds
            player.x = Math.max(player.size/2, Math.min(mapWidth - player.size/2, player.x));
            player.y = Math.max(player.size/2, Math.min(mapHeight - player.size/2, player.y));
        }

        function botAttack(player, attackType) {
            const now = Date.now();
            
            if (attackType === 'punch' && now - player.lastPunch < punchCooldown) return;
            if (attackType === 'kick' && now - player.lastKick < kickCooldown) return;
            
            if (attackType === 'punch') {
                player.lastPunch = now;
            } else {
                player.lastKick = now;
            }
            
            player.isAttacking = true;
            player.attackType = attackType;
            player.attackTimer = attackType === 'punch' ? 300 : 400;
            
            createAttackEffect(player.x, player.y, attackType);
            checkAttack(player, attackType);
        }

        function killPlayer(killer, victim) {
            killer.size = Math.min(maxPlayerSize, killer.size + 8);
            killer.points += 10;
            killer.kills++;
            killer.health = Math.min(killer.maxHealth, killer.health + 30);
            
            victim.size = minPlayerSize;
            victim.health = victim.maxHealth;
            victim.deaths++;
            victim.x = Math.random() * (mapWidth - 40) + 20;
            victim.y = Math.random() * (mapHeight - 40) + 20;
            
            updateLeaderboard();
            showKillNotification(killer.name, victim.name);
        }

        function showKillNotification(killer, victim) {
            // Create skull icon
            const skullIcon = document.createElement('div');
            skullIcon.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 60px;
                z-index: 1000;
                animation: skullBounce 1.5s ease-out;
                pointer-events: none;
            `;
            skullIcon.textContent = 'üíÄ';
            
            // Add skull animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes skullBounce {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.3) rotate(0deg); }
                    20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2) rotate(10deg); }
                    40% { transform: translate(-50%, -50%) scale(0.9) rotate(-5deg); }
                    60% { transform: translate(-50%, -50%) scale(1.1) rotate(3deg); }
                    80% { transform: translate(-50%, -50%) scale(0.95) rotate(-1deg); }
                    100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8) rotate(0deg); }
                }
            `;
            document.head.appendChild(style);
            
            document.body.appendChild(skullIcon);
            
            setTimeout(() => {
                if (document.body.contains(skullIcon)) {
                    document.body.removeChild(skullIcon);
                }
                if (document.head.contains(style)) {
                    document.head.removeChild(style);
                }
            }, 1500);
        }

        function render() {
            // Clear canvas
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            // Save context
            ctx.save();
            
            // Apply camera transform
            ctx.translate(-cameraX, -cameraY);
            
            // Draw background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, mapWidth, mapHeight);
            
            // Draw grid
            drawGrid();
            
            // Draw players
            for (let [id, player] of players) {
                drawStickFigure(player);
            }
            
            // Draw attack effects
            drawAttackEffects();
            
            // Restore context
            ctx.restore();
            
            // Update minimap
            updateMinimap();
        }

        function drawGrid() {
            ctx.strokeStyle = 'rgba(0,0,0,0.1)';
            ctx.lineWidth = 1;
            
            for (let x = 0; x < mapWidth; x += 20) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, mapHeight);
                ctx.stroke();
            }
            
            for (let y = 0; y < mapHeight; y += 20) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(mapWidth, y);
                ctx.stroke();
            }
        }

        function drawStickFigure(player) {
            const scale = player.size / 20;
            const x = player.x;
            const y = player.y;
            
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(scale, scale);
            ctx.scale(player.facing, 1);
            
            // Draw shadow
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(-3, 8, 6, 2);
            
            // Simple 2D stickman - one color
            ctx.strokeStyle = '#000';
            ctx.fillStyle = '#4ecdc4'; // Light blue
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            ctx.beginPath();
            
            // Head (round circle, no face)
            ctx.arc(0, -8, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Body (straight line)
            ctx.moveTo(0, -3);
            ctx.lineTo(0, 6);
            
            // Arms (stick-like but slightly thick)
            if (player.isAttacking && player.attackType === 'punch') {
                ctx.moveTo(0, -1);
                ctx.lineTo(12, 3);
                ctx.moveTo(0, -2);
                ctx.lineTo(-8, 2);
            } else if (player.isAttacking && player.attackType === 'kick') {
                ctx.moveTo(0, -1);
                ctx.lineTo(10, 2);
                ctx.moveTo(0, -2);
                ctx.lineTo(-8, 2);
            } else {
                ctx.moveTo(0, -1);
                ctx.lineTo(7, 2);
                ctx.moveTo(0, -2);
                ctx.lineTo(-7, 1);
            }
            
            // Legs (stick-like but slightly thick)
            if (player.isAttacking && player.attackType === 'kick') {
                ctx.moveTo(0, 6);
                ctx.lineTo(-5, 12);
                ctx.moveTo(0, 6);
                ctx.lineTo(15, 12);
            } else {
                ctx.moveTo(0, 6);
                ctx.lineTo(-5, 12);
                ctx.moveTo(0, 6);
                ctx.lineTo(5, 12);
            }
            
            ctx.stroke();
            
            // Simple armband on right arm
            ctx.fillStyle = '#ff6b35'; // Orange
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(3, 0, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            ctx.restore();
            
            // Player name
            ctx.fillStyle = '#000';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(player.name, x, y - player.size / 2 - 8);
            
            // Health bar
            const barWidth = 50;
            const barHeight = 5;
            const barX = x - barWidth / 2;
            const barY = y - player.size / 2 - 20;
            
            ctx.fillStyle = '#333';
            ctx.fillRect(barX, barY, barWidth, barHeight);
            
            const healthPercent = player.health / player.maxHealth;
            ctx.fillStyle = healthPercent > 0.5 ? '#4CAF50' : healthPercent > 0.25 ? '#ff9800' : '#f44336';
            ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
            
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.strokeRect(barX, barY, barWidth, barHeight);
        }

        function drawAttackEffects() {
            for (let i = attackEffects.length - 1; i >= 0; i--) {
                const effect = attackEffects[i];
                const progress = 1 - (effect.timer / effect.maxTimer);
                
                ctx.save();
                ctx.globalAlpha = 1 - progress;
                
                if (effect.type === 'punch') {
                    ctx.strokeStyle = '#ff6b35';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, 35 * progress, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.fillStyle = 'rgba(255, 107, 53, 0.3)';
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, 25 * progress, 0, Math.PI * 2);
                    ctx.fill();
                } else if (effect.type === 'kick') {
                    ctx.strokeStyle = '#ff6b35';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.ellipse(effect.x, effect.y, 45 * progress, 25 * progress, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.fillStyle = 'rgba(255, 107, 53, 0.3)';
                    ctx.beginPath();
                    ctx.ellipse(effect.x, effect.y, 35 * progress, 20 * progress, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
                
                effect.timer -= 16;
                if (effect.timer <= 0) {
                    attackEffects.splice(i, 1);
                }
            }
        }

        function updateMinimap() {
            minimapCtx.fillStyle = '#333';
            minimapCtx.fillRect(0, 0, 100, 100);
            
            const scaleX = 100 / mapWidth;
            const scaleY = 100 / mapHeight;
            
            for (let [id, player] of players) {
                const x = player.x * scaleX;
                const y = player.y * scaleY;
                const size = Math.max(2, player.size * scaleX / 4);
                
                minimapCtx.fillStyle = player.id === currentPlayerId ? '#4CAF50' : '#ff6b35';
                minimapCtx.beginPath();
                minimapCtx.arc(x, y, size, 0, Math.PI * 2);
                minimapCtx.fill();
            }
        }

        function updateLeaderboard() {
            const playersList = document.getElementById('playersList');
            
            const sortedPlayers = Array.from(players.values()).sort((a, b) => b.points - a.points);
            
            playersList.innerHTML = '';
            
            sortedPlayers.forEach((player, index) => {
                const playerItem = document.createElement('div');
                playerItem.className = 'player-item';
                
                playerItem.innerHTML = `
                    <div class="player-rank">${index + 1}</div>
                    <div class="player-name">${player.name}</div>
                    <div class="player-points">${player.points}</div>
                `;
                
                playersList.appendChild(playerItem);
            });
        }

        function gameLoop() {
            if (!gameRunning) return;
            
            for (let [id, player] of players) {
                updatePlayer(player);
            }
            
            render();
            requestAnimationFrame(gameLoop);
        }

        // Global functions
        function showControls() {
            alert('Controls:\nWASD - Move\nJ - Punch (damage: 25)\nK - Kick (damage: 35)\n\nKill enemies to grow bigger and stronger!');
        }

        function toggleFullscreen() {
            if (document.fullscreenElement) {
                document.exitFullscreen();
            } else {
                document.documentElement.requestFullscreen();
            }
        }

        // Music controls (your original code)
        const music = document.getElementById("bg-music");
        const toggleBtn = document.getElementById("toggle-music-btn");
        const volumeSlider = document.getElementById("volume-slider");

        let musicStarted = false;
        music.volume = 0.2;

        // User click ƒë·∫ßu ti√™n -> unmute + play
        window.addEventListener("click", () => {
            if (!musicStarted) {
                music.muted = false;
                music.play().catch(()=>{});
                musicStarted = true;
                toggleBtn.textContent = "üîá Mute Music";
            }
        }, { once: true });

        // Toggle button
        toggleBtn.addEventListener("click", () => {
            if (!musicStarted) {
                music.muted = false;
                music.play().catch(()=>{});
                musicStarted = true;
            } else {
                music.muted = !music.muted;
            }
            toggleBtn.textContent = music.muted ? "üîä Play Music" : "üîá Mute Music";
        });

        // Volume slider
        volumeSlider.addEventListener("input", () => {
            music.volume = volumeSlider.value / 100;
            document.getElementById('volumeText').textContent = volumeSlider.value + '%';
        });

        function renamePlayer() {
            const newName = document.getElementById('renameInput').value.trim();
            if (newName && newName.length > 0) {
                const player = players.get(currentPlayerId);
                if (player) {
                    player.name = newName;
                    updateLeaderboard();
                    document.getElementById('renameInput').value = '';
                    alert(`Player renamed to: ${newName}`);
                }
            } else {
                alert('Please enter a valid name!');
            }
        }

        // Blockchain Features
        async function sendReward(recipientAddress, amount) {
            if (!wallet || !publicKey) {
                alert('Please connect your wallet first!');
                return;
            }
            
            try {
                const transaction = new solanaWeb3.Transaction();
                const recipient = new solanaWeb3.PublicKey(recipientAddress);
                const lamports = amount * solanaWeb3.LAMPORTS_PER_SOL;
                
                transaction.add(
                    solanaWeb3.SystemProgram.transfer({
                        fromPubkey: publicKey,
                        toPubkey: recipient,
                        lamports: lamports
                    })
                );
                
                const signature = await wallet.signAndSendTransaction(transaction);
                console.log('Reward sent:', signature);
                return signature;
            } catch (error) {
                console.error('Failed to send reward:', error);
                alert('Failed to send reward: ' + error.message);
            }
        }

        async function mintNFT(metadata) {
            if (!wallet || !publicKey) {
                alert('Please connect your wallet first!');
                return;
            }
            
            try {
                // This would require a custom NFT minting program
                // For now, just log the metadata
                console.log('NFT Minting Request:', metadata);
                alert('NFT minting feature coming soon!');
            } catch (error) {
                console.error('Failed to mint NFT:', error);
                alert('Failed to mint NFT: ' + error.message);
            }
        }

        // Buy $STICK Token function
        function buyStickToken() {
            if (!wallet || !publicKey) {
                alert('Please connect your wallet first!');
                return;
            }
            
            const tokenAddress = '7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU';
            const dexUrl = `https://jup.ag/swap/SOL-${tokenAddress}`;
            
            // Open Jupiter DEX for swapping
            window.open(dexUrl, '_blank');
            
            console.log('Opening Jupiter DEX for $STICK token purchase');
        }

        // Enhanced kill function with blockchain rewards
        function killPlayerWithReward(attacker, victim) {
            // Original kill logic
            victim.health = 0;
            attacker.kills++;
            attacker.points += 10;
            attacker.size = Math.min(maxPlayerSize, attacker.size + 5);
            
            // Blockchain reward
            if (publicKey && attacker.id === currentPlayerId) {
                // Send small SOL reward
                setTimeout(() => {
                    sendReward(publicKey.toString(), 0.001); // 0.001 SOL reward
                }, 1000);
                
                // Mint achievement NFT
                const nftMetadata = {
                    name: `Kill #${attacker.kills}`,
                    description: `You killed ${victim.name}!`,
                    image: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZmY2YjM1Ii8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIyMCIgZmlsbD0id2hpdGUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj7wn5GAPC90ZXh0Pjwvc3ZnPg==',
                    attributes: [
                        { trait_type: 'Kill Count', value: attacker.kills },
                        { trait_type: 'Victim', value: victim.name },
                        { trait_type: 'Timestamp', value: Date.now() }
                    ]
                };
                
                setTimeout(() => {
                    mintNFT(nftMetadata);
                }, 2000);
            }
            
            // Respawn victim
            setTimeout(() => {
                victim.health = victim.maxHealth;
                victim.x = Math.random() * (mapWidth - 40) + 20;
                victim.y = Math.random() * (mapHeight - 40) + 20;
                victim.size = minPlayerSize;
            }, 2000);
        }

        // Initialize game when page loads
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>

